# ========== Docker æ„å»ºéƒ¨ç½²å·¥ä½œæµ ==========
name: ğŸ³ Docker Build & Deploy

# ========== è§¦å‘æ¡ä»¶ ==========
on:
  push:
    tags:
      - "v*" # ç‰ˆæœ¬æ ‡ç­¾è§¦å‘
  workflow_dispatch: # æ‰‹åŠ¨è§¦å‘
    inputs:
      version:
        description: "éƒ¨ç½²ç‰ˆæœ¬ (é»˜è®¤: latest)"
        required: false
        default: "latest"

# ========== ç¯å¢ƒå˜é‡é…ç½® ==========
env:
  # ğŸ”§ é¡¹ç›®é…ç½® (æŒ‰éœ€ä¿®æ”¹)
  PROJECT_NAME: "user_server"
  GRPC_SERVER_BINARY: "user_server_grpc"
  HTTP_SERVER_BINARY: "user_server_http"
  RUST_TARGET: "x86_64-unknown-linux-musl"

  # ğŸ“ ç›®å½•é…ç½® (æŒ‰éœ€ä¿®æ”¹)
  REMOTE_DEPLOY_DIR: "/micro-server/user-server/deploy/"
  REMOTE_CONFIG_DIR: "/micro-server/user-server/deploy/config/"

  # ğŸ³ Docker é…ç½®
  DOCKER_COMPOSE_FILE: "docker-compose.yml"
  GRPC_SERVER_IMAGE: "user_server_grpc"
  HTTP_SERVER_IMAGE: "user_server_http"
  GRPC_DOCKER_FILE: "Dockerfile.grpc"
  HTTP_DOCKER_FILE: "Dockerfile.http"
  GRPC_PORT: 50000
  HTTP_PORT: 8899
  ENV_FILE: ".env_prod"
  CONFIG_FILE: "prod.yml"

# ========== å·¥ä½œæµå®šä¹‰ ==========
jobs:
  # é˜¶æ®µ1: æ„å»ºé™æ€äºŒè¿›åˆ¶æ–‡ä»¶
  build:
    name: ğŸ”¨ Build a static binary file
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.VERSION }}
      is_tag: ${{ steps.version.outputs.IS_TAG }}
    steps:
      # æ­¥éª¤1: æ£€å‡ºä»£ç 
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
      # æ­¥éª¤2: å®‰è£… Protoc
      - name: ğŸ—ï¸ Install Protoc
        uses: arduino/setup-protoc@v3
      # æ­¥éª¤3: è®¾ç½® Rust musl ç¯å¢ƒ
      - name: âš™ï¸ Setup Rust Musl Environment
        run: |
          # å®‰è£… Rust
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
          source $HOME/.cargo/env

          # å®‰è£… musl ç›®æ ‡
          rustup target add x86_64-unknown-linux-musl

          # å®‰è£… musl å·¥å…·
          sudo apt-get update
          sudo apt-get install -y musl-tools musl-dev

          # é…ç½® Cargo
          mkdir -p .cargo
          cat > .cargo/config.toml << EOF
          [target.x86_64-unknown-linux-musl]
          linker = "x86_64-linux-musl-gcc"
          EOF

          echo "âœ… Rust musl ç¯å¢ƒè®¾ç½®å®Œæˆ"

      # æ­¥éª¤4: ç¼“å­˜ä¾èµ–
      - name: ğŸ“¦ Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      # æ­¥éª¤5: æ„å»ºé™æ€äºŒè¿›åˆ¶æ–‡ä»¶
      - name: ğŸ”¨ Build static binary
        run: |
          source $HOME/.cargo/env
          export RUSTFLAGS="-C linker=x86_64-linux-musl-gcc"

          echo "ğŸ—ï¸ å¼€å§‹æ„å»º..."
          cargo build --release --bin ${{ env.GRPC_SERVER_BINARY }} --target ${{ env.RUST_TARGET }}
          cargo build --release --bin ${{ env.HTTP_SERVER_BINARY }} --target ${{ env.RUST_TARGET }}

          # éªŒè¯æ„å»ºç»“æœ - åˆ†åˆ«æ£€æŸ¥ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
          GRPC_BINARY_PATH="target/${{ env.RUST_TARGET }}/release/${{ env.GRPC_SERVER_BINARY }}"
          HTTP_BINARY_PATH="target/${{ env.RUST_TARGET }}/release/${{ env.HTTP_SERVER_BINARY }}"

          # éªŒè¯ gRPC æœåŠ¡å™¨
          if [ -f "$GRPC_BINARY_PATH" ]; then
            echo "âœ… gRPC æœåŠ¡å™¨æ„å»ºæˆåŠŸ: $GRPC_BINARY_PATH"
            echo "ğŸ“Š æ–‡ä»¶ä¿¡æ¯:"
            file "$GRPC_BINARY_PATH"
            echo "ğŸ’¾ æ–‡ä»¶å¤§å°:"
            du -h "$GRPC_BINARY_PATH"
          else
            echo "âŒ gRPC æœåŠ¡å™¨æ„å»ºå¤±è´¥: æ–‡ä»¶ä¸å­˜åœ¨"
            exit 1
          fi

          # éªŒè¯ HTTP æœåŠ¡å™¨
          if [ -f "$HTTP_BINARY_PATH" ]; then
            echo "âœ… HTTP æœåŠ¡å™¨æ„å»ºæˆåŠŸ: $HTTP_BINARY_PATH"
            echo "ğŸ“Š æ–‡ä»¶ä¿¡æ¯:"
            file "$HTTP_BINARY_PATH"
            echo "ğŸ’¾ æ–‡ä»¶å¤§å°:"
            du -h "$HTTP_BINARY_PATH"
          else
            echo "âŒ HTTP æœåŠ¡å™¨æ„å»ºå¤±è´¥: æ–‡ä»¶ä¸å­˜åœ¨"
            exit 1
          fi

      # æ­¥éª¤6: æå–ç‰ˆæœ¬å·
      - name: ğŸ·ï¸ Extract version tag
        id: version
        run: |
          if [[ "${{ github.ref }}" =~ ^refs/tags/v([0-9]+\.[0-9]+(\.[0-9]+)*) ]]; then
            VERSION="${BASH_REMATCH[1]}"
            IS_TAG="true"
            echo "âœ… æå–åˆ°ç‰ˆæœ¬å·: $VERSION"
          elif [[ "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            IS_TAG="false"
          else
            VERSION="latest"
            IS_TAG="false"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "IS_TAG=$IS_TAG" >> $GITHUB_OUTPUT
          echo "âœ… ä½¿ç”¨ç‰ˆæœ¬: $VERSION"

      # æ­¥éª¤7: ä¸ºä¸¤ä¸ªæœåŠ¡åˆ†åˆ«å‡†å¤‡éƒ¨ç½²åŒ…
      - name: ğŸ“¦ Prepare deployment package
        run: |
          # åˆ›å»ºéƒ¨ç½²ç›®å½•
          mkdir -p deploy-package

          echo "ğŸ“ å‡†å¤‡éƒ¨ç½²æ–‡ä»¶..."

          # 1. å¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
          cp -v "target/${{ env.RUST_TARGET }}/release/${{ env.GRPC_SERVER_BINARY}}" deploy-package/
          cp -v "target/${{ env.RUST_TARGET }}/release/${{ env.HTTP_SERVER_BINARY}}" deploy-package/

          # 2. è®¾ç½®æ‰§è¡Œæƒé™
          chmod +x deploy-package/${{ env.GRPC_SERVER_BINARY}} deploy-package/${{ env.HTTP_SERVER_BINARY}}

          # 3. å¤åˆ¶ Dockerfile
          cp -v ${{ env.GRPC_DOCKER_FILE}} ${{ env.HTTP_DOCKER_FILE}} ${{ env.DOCKER_COMPOSE_FILE}} deploy-package/

          # 4. å¤åˆ¶é…ç½®æ–‡ä»¶
          mkdir -p deploy-package/config
          cp -v ${{ env.CONFIG_FILE }} deploy-package/config/ 2>/dev/null || true

          # 5. åˆ›å»º .env ç¯å¢ƒæ–‡ä»¶
          echo "âœ… åˆ›å»º .env ç¯å¢ƒæ–‡ä»¶"
          cat > deploy-package/${{ env.ENV_FILE }} << EOF
          CURRENT_VERSION=${{ env.VERSION }}
          GRPC_SERVER_IMAGE_NAME=${{ env.GRPC_SERVER_IMAGE }}
          HTTP_SERVER_IMAGE_NAME=${{ env.HTTP_SERVER_IMAGE }}
          GRPC_PORT=${{ env.GRPC_PORT }}
          HTTP_PORT=${{ env.HTTP_PORT }}
          RUST_LOG=info
          EOF

          echo "ğŸ“ éƒ¨ç½²åŒ…å†…å®¹:"
          ls -la deploy-package/

          # åˆ›å»ºå‹ç¼©åŒ…
          tar czf deployment-${{ env.VERSION }}.tar.gz -C deploy-package .

      # æ­¥éª¤8: ä¸Šä¼ æ„å»ºäº§ç‰©
      - name: ğŸ“¤ Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-${{ env.VERSION }}
          path: deployment-${{ env.VERSION }}.tar.gz
          retention-days: 1

  # é˜¶æ®µ2: éƒ¨ç½²åˆ°æœåŠ¡å™¨
  deploy:
    name: ğŸš€ Deploy to the remote server
    runs-on: ubuntu-latest
    needs: build
    environment: production

    steps:
      # æ­¥éª¤1: ä¸‹è½½æ„å»ºäº§ç‰©
      - name: ğŸ“¥ Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-${{ needs.build.outputs.version }}

      # æ­¥éª¤2: è®¾ç½® SSH
      - name: ğŸ”‘ Setup SSH
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      # æ­¥éª¤3: æµ‹è¯• SSH è¿æ¥
      - name: ğŸ§ª Test SSH connection
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }} \
            "echo 'âœ… SSH è¿æ¥æˆåŠŸ' && docker --version && docker compose version"

      # æ­¥éª¤4: ä¸Šä¼ æ„å»ºåŒ…
      - name: ğŸ“¤ Upload to server
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ secrets.REMOTE_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "deployment-${{ needs.build.outputs.version }}.tar.gz"
          target: ${{ env.REMOTE_DEPLOY_DIR }}
          timeout: 300s

      # æ­¥éª¤5: æ‰§è¡Œè¿œç¨‹éƒ¨ç½²
      - name: ğŸš€ Execute deployment
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.REMOTE_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          timeout: 10m
          script: |
            set -e
            cd ${{ env.REMOTE_DEPLOY_DIR }}

            echo "ğŸ”§ å¼€å§‹éƒ¨ç½²æµç¨‹..."

            # åœæ­¢ç°æœ‰æœåŠ¡
            docker compose down 2>/dev/null || echo "âš ï¸ æ— è¿è¡Œä¸­çš„æœåŠ¡"

            # æ¸…ç†æ—§æ–‡ä»¶
            rm -rf ${{ env.GRPC_SERVER_BINARY }} ${{ env.HTTP_SERVER_BINARY }} ${{ env.DOCKER_COMPOSE_FILE }} ${{ env.ENV_FILE }} ./config/${{ env.CONFIG_FILE }} ${{ env.GRPC_DOCKER_FILE }} ${{ env.HTTP_DOCKER_FILE }} deploy-package

            # æ¸…é™¤ tar.gz æ–‡ä»¶
            echo "ğŸ“¦ æ¸…ç†æ—§çš„éƒ¨ç½²åŒ…..."
            KEEP_COUNT=2

            # è·å–æ–‡ä»¶åˆ—è¡¨å¹¶æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
            files=($(ls -t deployment-*.tar.gz 2>/dev/null))

            if [ ${#files[@]} -le $KEEP_COUNT ]; then
                echo "ğŸ“ æ–‡ä»¶æ•°é‡ (${#files[@]}) ä¸è¶…è¿‡ä¿ç•™æ•°é‡ ($KEEP_COUNT)ï¼Œæ— éœ€æ¸…ç†"
                exit 0
            fi

            echo "ğŸ“Š å‘ç° ${#files[@]} ä¸ªéƒ¨ç½²åŒ…æ–‡ä»¶ï¼Œä¿ç•™æœ€æ–°çš„ $KEEP_COUNT ä¸ª"

            # åˆ é™¤æ—§æ–‡ä»¶
            for ((i=KEEP_COUNT; i<${#files[@]}; i++)); do
                echo "ğŸ—‘ï¸  åˆ é™¤: ${files[i]}"
                rm -f "${files[i]}"
            done

            echo "âœ… æ¸…ç†å®Œæˆï¼å‰©ä½™æ–‡ä»¶:"
            ls -lh deployment-*.tar.gz 2>/dev/null || echo "ğŸ“­ æ²¡æœ‰æ‰¾åˆ° deployment-*.tar.gz æ–‡ä»¶"

            # è§£å‹éƒ¨ç½²åŒ…
            tar xzf deployment-${{ needs.build.outputs.version }}.tar.gz

            # éªŒè¯å¿…è¦æ–‡ä»¶
            for file in ${{ env.GRPC_SERVER_BINARY }} ${{ env.HTTP_SERVER_BINARY }} ${{ env.DOCKER_COMPOSE_FILE }} ./config/${{ env.CONFIG_FILE }} ${{ env.GRPC_DOCKER_FILE }} ${{ env.HTTP_DOCKER_FILE }} ${{ env.ENV_FILE }}; do
              [ -f "$file" ] || { echo "âŒ æ–‡ä»¶ç¼ºå¤±: $file"; exit 1; }
            done

            chmod +x "${{ env.GRPC_SERVER_BINARY }}"
            chmod +x "${{ env.HTTP_SERVER_BINARY }}"

            # å¤åˆ¶é…ç½®æ–‡ä»¶
            mkdir -p ${{ env.REMOTE_CONFIG_DIR }}
            [ -f "${{ env.CONFIG_FILE }}" ] && cp -f ${{ env.CONFIG_FILE }} ${{ env.REMOTE_CONFIG_DIR }}prod.yml || true

            # æ„å»ºå¹¶å¯åŠ¨æœåŠ¡
            docker compose --env-file ${{ env.ENV_FILE }} -f ${{ env.DOCKER_COMPOSE_FILE }} build --no-cache
            docker compose --env-file ${{ env.ENV_FILE }} -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

            # ç­‰å¾…æœåŠ¡å¯åŠ¨
            sleep 10

            # éªŒè¯æœåŠ¡çŠ¶æ€
            echo "ğŸ“Š æœåŠ¡çŠ¶æ€:"
            docker ps --filter "name=${{ env.PROJECT_NAME }}"

            # æ¸…ç†æ—§é•œåƒ
            echo "ğŸ§¹ æ™ºèƒ½æ¸…ç†æ—§é•œåƒï¼ˆæ¯ä¸ªæœåŠ¡ä¿ç•™æœ€æ–°ç‰ˆæœ¬ï¼‰..."
            echo "ğŸ“¦ æ¸…ç† GRPC ç›¸å…³çš„æ—§é•œåƒ..."
            CURRENT_GRPC_IMAGE=$(docker inspect ${{ env.GRPC_SERVER_IMAGE }} --format '{{.Config.Image}}' 2>/dev/null || echo "")
            [ -n "$CURRENT_GRPC_IMAGE" ] && echo "ğŸ†• å½“å‰é•œåƒ: $CURRENT_GRPC_IMAGE"

            docker images --filter "reference=*${{ env.GRPC_SERVER_IMAGE }}*" --format "{{.Repository}}:{{.Tag}}" | \
            while read -r image; do
              if [ "$image" != "$CURRENT_GRPC_IMAGE" ] && [ -n "$image" ]; then
                echo "ğŸ—‘ï¸ åˆ é™¤: $image"
                docker rmi "$image" 2>/dev/null || echo "âš ï¸ æ— æ³•åˆ é™¤ $image"
              fi
            done

            echo "ğŸ“¦ æ¸…ç† HTTP ç›¸å…³çš„æ—§é•œåƒ..."
            CURRENT_HTTP_IMAGE=$(docker inspect ${{ env.HTTP_SERVER_IMAGE }} --format '{{.Config.Image}}' 2>/dev/null || echo "")
            [ -n "$CURRENT_HTTP_IMAGE" ] && echo "ğŸ†• å½“å‰é•œåƒ: $CURRENT_HTTP_IMAGE"

            docker images --filter "reference=*${{ env.HTTP_SERVER_IMAGE }}*" --format "{{.Repository}}:{{.Tag}}" | \
            while read -r image; do
              if [ "$image" != "$CURRENT_HTTP_IMAGE" ] && [ -n "$image" ]; then
                echo "ğŸ—‘ï¸ åˆ é™¤: $image"
                docker rmi "$image" 2>/dev/null || echo "âš ï¸ æ— æ³•åˆ é™¤ $image"
              fi
            done
            # æ¸…ç†æ‚¬ç©ºé•œåƒ
            echo "ğŸ§½ æ¸…ç†æ‚¬ç©ºé•œåƒ..."
            docker image prune -f 2>/dev/null || true

            echo "ğŸ“‹ æ¸…ç†åçš„é•œåƒåˆ—è¡¨:"
            docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}" | grep -E "(${{env.PROJECT_NAME}}_|REPOSITORY)" || true

            echo ""
            echo "âœ… æ¸…ç†å®Œæˆï¼æ¯ä¸ªæœåŠ¡åªä¿ç•™æ­£åœ¨ä½¿ç”¨çš„é•œåƒ"
            echo "ğŸ‰ éƒ¨ç½²å®Œæˆï¼å½“å‰è¿è¡Œç‰ˆæœ¬: ${{ needs.build.outputs.version }}"
